README
-----
Instalation:
------------
The PARIS code needs to be compiled manually. So far, it has been tested
on several UNIX systems: OS X, Debian (aka Ubuntu), RHEL.
The mainline version of PARIS is compiled by a standard

make && make install

combo (actually the later command is sufficient). Several requirements:
1. you must have an active mpif90 (openmpi packages on most UNIX systems)
2. reasonably new versions of gfortran or intel fortran are assumed.
3. Several libraries are available or can be used together with PARIS:
   in mainline code those are VOFI, HYPRE and SILO.
   Neither of these is supplied with the code. By default, you should obtain
   them and know their locations.

3a.  to compile with VOFI type:
       make HAVE_VOFI=1
     and set:
       USE_VOFI = T

     in the "inputvof" parameter file.
  The VOFI_DIR variable holds physical location of the library in your system.
  This is assumed to be $HOME/lib. You must change it manually if you decide
  on different location.

3b. Similar prequisites are assumed for HYPRE (used to speed up the Poisson equation
    solution) and SILO (used for an efficient, parallel output with compression).
    Both libraries have been created at LLNL and can be found here:
    http://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods
    https://wci.llnl.gov/simulation/computer-codes/silo/releases

    If Silo is not compiled, PARIS will output to uncompressed VTK format by default.

Note that after make finishes, the paris executable is put in $HOME/bin by default.
This can be modified in the Makefile.

4. PARIS installation includes a suite of tests which the solver passes at each
   new release. To use them, issue the 'make test' command (standard suite),
   'make longtest' (slightly more tests) or 'make hardtest' (long & hard version
   using the code compiled with debugging flags).

 4a. Generally, the test suite is a collection of BASH  scripts. It implicitly assumes that
     the directory used to hold the paris executable (by default $HOME/bin/) is in users's PATH
     variable. If the paris executable's location is changed, the user should add its location
     to PATH in order to use the test suite.

 4b. The test suite utilizes three utility programs: pariscompare, pariscompare3D and parisdeconv.
     Written in C, these codes are compiled into three respective executables. Note that those
     must also be in a location known to BASH (so declared in PATH).

     To summarize, it is assumed the $HOME/bin directory is in user's PATH, please adjust
     the locations to fit your system.

 4c. Note that if several version/revisions/branches of PARIS exist simultaneously in the
     same system, keeping their respective executables in $HOME/bin may, and will cause conflicts.


5.  Mainline PARIS Makefile creates also the 'TAGS' file used by Emacs. This is done using etags.
   
 

Fortran 90/95
-------------

- no need to declare functions in module. 
- initialized values are not saved between calls to subroutine

Parallel/MPI/grid size/Hypre
----------------------------

Some of the solvers in hypre have power-of-two restrictions on the size of the periodic dimensions.
Hypre uses the L1 norm. 

Grid and array index conventions
--------------------------------

1) Staggered grid

       x--->---x 
       |   :   |   
       ^...:...^ 
       |   :   |   
       x--->---x 

x: pressure, density and VOF (p, rho and cvof) nodes. 
>: u nodes
^: v nodes

2) One-dimensional view

2a) bulk indices 

u(i-1)  p(i)    u(i)   p(i+1)
-->------x------->------x--   
        x(i)    xh(i)            		                   


u(i) is at xh(i)  (xh means x half, maps to  i + 1/2)
p(i), rho(i) at x(i)  (x maps to i)
x(i) between xh(i-1) and xh(i)

2b) beginning /end of subdomain of grid

start/end of non-ghost points:is,ie

 * Basic principle for a single domain of size L

 x=0                             x=L
  >--x-->--x-->  ...  >--x-->--x--> 
  |                               |
beginning                         end

There are Ng ghost points to the right and left
 
   is = Ng + 1; ie = Ng + Nx
        			
 * For multiple subpdomains:
                    
                   p(is)                     p(ie)
(end ghost        >--x-->--x-->  ...  >--x-->--x--> ( begin ghost / other domain)
and other domain) |                               |
                u(is-1)                         u(ie)
                xh(is-1)                        xh(ie)

xh(i=Ng) = 0
xh(i=Nx+Ng) = xLength

layout of array including ghost layers/points given by array declaration e.g. p(imin:imax)

Special conventions for velocity:
  ieu=ie; if(bdry_cond(1)/='periodic' .and. coords(1)==nPx-1) ieu=ie-1

2c) Boundary conditions at x=0 (left boundary)


u(is-1) p(is)  u(is)   p(is+1) 
  >------x------->-------x-----
apply BC
here

first calculated velocity point is
first corrected  velocity is
first calculated pressure point is p(is)


2d) Boundary conditions at x=L (right boundary)

                         ieu
     u(ie-1)    p(ie)  u(ie)   p(ie+1)
...----->---------x------>------x-
	:                |      ! beginning of
	:               Xlength   GHOST POINTS	
	:
    boundary      rightmost
    last correc-  pressure point	
    ted velocity  in correction


last calculated velocity point ieu = IE-1
last corrected  velocity ieu
last calculated pressure point is p(ie)



Pressure boundary conditions
----------------------------


Outflow/fixed velocity (bdry_cond = 4)
set u(ie) ==  u(ieu+1) to given outflow/fixed value
last pressure updated ie, last velocity updated ieu  --> 
replace gradient between ie and ie+1 by zero. 
Thus  A(ie,j,k,2) * (p(ie+1,j,k) - p(ie,j,k)) = 0 
and 
A(ie,:,:,2) = 0

same thing for presssure condition
Fix p(ie) 
set A(ie,:,:,2) = 0 


VOF issues
----------

1) Divergence


   du/dx = (u(i) - u(i-1)) / (xh(i) - xh(i-1))  = u(i) - u(i-1) / dx(i) 

   vof2 = du/dx C(u(i-1/2))

2) rescaling

  u * dt / dx = u(i) * dt / dxh(i) 

3) Front-VOF merge:

problem linfunc in nPdomain. 
